<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Тестовый</title>
    <link rel="stylesheet" type="text/css" href="../css/style.css">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,100i,300,300i,400,400i" rel="stylesheet">
    <script src="../es5-shim-master/es5-shim.js"></script>
</head>

<body>

<div id="main">
    <div class="menu">
        <ul id="menu"></ul>
    </div>

    <h1><a href="docs/async.pdf" target="_blank"></a> Асинхронность</h1>

    <ul id="tabs">
        <li id="tab1" class="selected_tab"><a href="#">Таймеры</a></li>
        <li id="tab2" class="tab"><a href="#" title="Асинхронность">Асинхронность</a></li>
        <li id="tab2" class="tab"><a href="#" title="Promise и Deferred">Promise и Deferred</a></li>
        <li id="tab2" class="tab"><a href="#" title="AJAX">AJAX</a></li>
        <li id="tab2" class="tab"><a href="#" title="XMLHTTPRequest">XMLHTTPRequest</a></li>
        <li id="tab2" class="tab"><a href="#" title="JSON">JSON</a></li>
        <li id="tab2" class="tab"><a href="#" title="Cross Origin Resource Sharing">Cross Origin Resource Sharing</a></li>
        <li id="tab2" class="tab"><a href="#" title="JSON-P">JSON-P</a></li>
        <li id="tab2" class="tab"><a href="#" title="AJAX в jQuery">AJAX в jQuery</a></li>
    </ul>

    <div id="content">
        <!-- Таймеры -->
        <div id="cont1" class="show">
            <h2>Таймеры</h2>
            <p>В JavaScript <b>нет</b> встроенного способа <b>задержать</b> выполнение скрипта на определенное время, но есть способы запустить код через определенный промежуток времени или непрерывно, через интервал.</p>
            
            <table class="func">
                <tr>
                    <td width="30%">setTimeout(fn, ms)</td>
                    <td>запустить код один раз через указанное количество миллисекунд</td>
                </tr>
                <tr>
                    <td>clearTimeout(timeoutId)</td>
                    <td>отменить назначенный запуск</td>
                </tr>
                <tr>
                    <td>setInterval(fn, ms)</td>
                    <td>запускать код с указанной периодичностью</td>
                </tr>
                <tr>
                    <td>clearInterval(timeoutId)</td>
                    <td>отменить setInterval</td>
                </tr>
            </table>

            
        </div>
     
        <!-- Асинхронность -->
        <div id="cont2" class="cont">
            <h2>Основные компоненты BOM</h2>
            <p><b>Асинхронность</b> подразумевает, что можно выполнять <b>несколько</b> задач(кусков кода) <b>одновременно</b>.</p>
            <p>Бытует неверное мнение, что JS является асинхронным языком.</p>

            <div class="info"><p>В JS создается лишь <b>видимость</b> асинхронности за счет так называемого <b>цикла</b> событий. Влиять на цикл события можно при помощи <b>setTimeout</b> и <b>setInterval</b>. Эти методы всего лишь <b>имитируют</b> асинхронность.</p></div>
        </div>

        <!-- Promise и Deferred -->
        <div id="cont3" class="cont">
            <h2>Promise и Deferred</h2>
            <p><b>Promise(промис)</b> - это способ <b>организации</b> кода.</p>

            <p>Для создания промиса, необходима <b>функция</b>, в которой выполняется какая-то <b>задача</b>.</p>

            <p>При создании промиса, в эту функцию автоматически передаются два аргумента:</p>

            <ul class="list">
                <li>resolve callback</li>
                <li>reject callback</li>
            </ul>

            <p>Задача функции - вызвать одну из функций, исходя из результата своей работы (resolve - успех, reject - неудача)</p>

            <p>На <i>полученный</i> объект промиса можно <i>“навесить”</i> так называемые <b>then callbacks</b> - функции, которые будут запущены <b>автоматически</b>, в зависимости от <i>результата</i> выполнения основной функции промиса. Количество таких <b>callbacks</b> - не ограничено.</p>

            <div class="info"><p>Промисы можно <i>cгруппировать</i> в один объект. В этом случае, можно “навесить” на все сгруппированные промисы один <b>then callback</b>, который выполнится, когда <b>все</b> или <b>часть</b> промисов группы будут выполнены или отклонены.</p></div>

            <p>Вызвать <b>resolve</b> или <b>reject</b> можно только <i>изнутри</i> основной функции.</p>

            <p><b>Deferred-объект</b> - это небольшая надстройка над промисом, которая позволяет вызвать <b>resolve</b> или <b>reject</b> из любой точки кода, а не только изнутри основной функции промиса.</p>

            <p>У классического <b>Deferred</b> обычно всего <b>два</b> метода (<b>resolve</b>, <b>reject</b>) и одно свойство <b>promise</b>, при помощи которого, можно навешивать <b>then callbacks</b> на промис Deferred-объекта</p>

        </div>

        <!-- AJAX -->
        <div id="cont4" class="cont">
            <h2>AJAX</h2>
            <p><b>AJAX</b> - механизм, встроенный в веб-браузер, позволяющий <b>посылать</b> запрос на сервер и обрабатывать <b>ответ</b> от сервера <i>не перезагружая</i> страницу. </p>

            <p>Как результат - создается иллюзия desktop-приложения.</p>

            <p>За реализацию <b>AJAX</b>, отвечает объект <b>XMLHttpRequest</b></p>
        </div>

        <!-- XMLHTTPRequest -->
        <div id="cont5" class="cont">
            <h2>XMLHTTPRequest</h2>
            <p>Для использования AJAX, необходимо:</p>
            <ul class="list">
                <li>создать новый объект типа XMLHTTPRequest</li>
                <li>вызвать метод open(method, url, async)</li>
                <li>добавить обработчики на все или некоторые события</li>
                <li>вызвать метод send()</li>
            </ul>
            <p>Результат запроса будет храниться в свойстве response или responseText.</p>

            <p>Если возникла ошибка, то http-код ошибки будет храниться в свойстве status.</p>

            <h3>Обработчики на события:</h3>

            <table class="func">
                <tr>
                    <td width="30%">onloadstart</td>
                    <td>загрузка началась</td>
                </tr>
                <tr>
                    <td>onreadystatechange </td>
                    <td>смена состояния запроса</td>
                </tr>
                <tr>
                    <td>onprogress</td>
                    <td>браузер получил новые данные</td>
                </tr>
                <tr>
                    <td>onloadend</td>
                    <td>загрузка закончилась (успешно или с ошибкой)</td>
                </tr>
            </table>
        </div>

        <!-- JSON -->
        <div id="cont6" class="cont">
            <h2>JSON</h2>
            <p><b>JSON (JavaScript Object Notation)</b> - формат данных, совместимый со способом описания обычного javascript-объекта.</p>

            <p>По умолчанию, XMLHTTPRequest не преобразует http-ответ в json.</p>

            <p>Чтобы сделать это, перед отправкой запроса, необходимо установить свойство responseType в ‘json’.</p>

            <p>В таком случае ответ, преобразованный в json, будет храниться в свойство response.</p>
        </div>

        <!-- Cross Origin Resource Sharing -->
        <div id="cont7" class="cont">
            <h2>Cross Origin Resource Sharing</h2>
            <p>По умолчанию, браузер не позволит отправлить ajax-запросы на сервер, хост или порт которого, отличный от того, с которого получена страница.</p>

            <p>Но при помощи CORS, эта проблема легко решается.</p>

            <p>Ее суть сводится к тому, что сервер, при ответе, отдает специальный заголовок: Access-Control-Allow-Origin: ….</p>

            <p>Этот заголовок дает браузеру понять - кто может отправлять данному серверу кросс-доменные ajax-запросы.</p>
        </div>

        <!-- JSON-P -->
        <div id="cont8" class="cont">
            <h2>JSON-P</h2>
            <p><b>JSON-P</b> - один из методов, позволяющий обойти ограничения, накладываемые браузером на кросс-доменные запросы.</p>

            <p>Суть метода сводится к тому, что браузер загружает специальный javascript-файл, который, после окончания загрузки, вызывает заранее установленную глобальную функцию и передает ей в качестве аргументов - данные.</p>

            <p>Задача разработчика состоит в том, чтобы обработать полученные данные.</p>

            <p>Чаще всего, такие javascript-файлы генерируются динамически (с подменой заголовков сервером) и не являются javascript-файлами как таковыми.</p>
        </div>

        <!-- AJAX в jQuery -->
        <div id="cont9" class="cont">
            <h2>AJAX в jQuery</h2>
            <table class="jq">
                <tr>
                    <td width="30%">$.<span class="orange">ajax</span>(<span class="green">параметры</span>)</td>
                    <td>функция, формирующая ajax-зарпос. Может принимать большое количество параметров</td>
                </tr>
                <tr>
                    <td>$.<span class="orange">get</span>(<span class="green">url</span>, [<span class="green">обработчик</span>], [<span class="green">тип ответа</span>]) </td>
                    <td>отправить get-зарпос</td>
                </tr>
                <tr>
                    <td>$.<span class="orange">post</span>(<span class="green">url</span>, [<span class="green">данные</span>], [<span class="green">тип ответа</span>])</td>
                    <td>отправить post-зарпос</td>
                </tr>
                <tr>
                    <td>$(<span class="green">селектор</span>).<span class="orange">load</span>(<span class="green">url</span>)</td>
                    <td>загрузить содержимое из внешнего источника и поместить внутрь элемента</td>
                </tr>
            </table>
        </div>
    </div>

    
</div>

</body>

    <script src="../js/menu.js"></script>
    <script src="../js/script.js"></script>
    <script src="../js/async.js"></script>
</html>